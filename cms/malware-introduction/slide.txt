<style type="text/css">
  .reveal p {
    text-align: justify;
    font-size: 0.8em;
  }
  .reveal ul {
    display: block;
  }
  .reveal ol {
    display: block;
  }
</style>

# 恶意代码

---

## 基本概念

--

### 概念

<b style="color:red">恶意代码：Malicious Code</b>，<b style="color:red">恶意软件：Malware</b>，<b style="color:red">垃圾（信息）：Spam</b>等多种往往都属于恶意代码的不同类型；恶意代码的核心特征是执行结果非用户期望且包含恶意目的，恶意软件往往是指以软件形式存在的恶意代码；垃圾信息可以借助恶意代码和恶意软件加速传播，也可以反过来帮助恶意代码加速传播。

---

## 发展阶段

--

### 原始病毒

原始病毒阶段更多地是出于兴趣和恶作剧性质的玩笑。

1. 产生年限为 1986-1989 年之间。
2. 由于当时的计算机软件少，大多是单机运行，病毒没有大量流行，种类有限，清除相对容易。
3. 攻击目标较单一，主要通过截获系统中端向量的方式监视系统的运行状态，并在一定的条件下传染。
4. 病毒不具备自我保护的措施。

<!-- .element style="font-size:70%;"-->

--

### 混合病毒

该阶段，恶意代码已经开始有一些目的性和自我保护机制：

1. 产生年限在 1989-1991 年之间，是计算机病毒由简单发展到复杂的阶段。
2. 计算机局域网的应用和普及给计算机病毒带来了第一次流行高峰。
3. 攻击目标趋于混合，采取更隐蔽的方式驻留内存和传染目标，并且没有明显的特征，采取了自我保护的措施，出现很多的病毒的变种。

<!-- .element style="font-size:70%;"-->

--

### 多态病毒

正式进入对抗时代：

1. 在每次传染目标时，宿主程序中的病毒程序大部分是可变的，防病毒软件查杀时非常困难。
2. 这一阶段开始，病毒技术开始向多维化方向发展

<!-- .element style="font-size:70%;"-->

--

### 网络病毒

互联网出现使得恶意代码作者能够获取更大的利益或“成就感”：

1. 从 20 世纪 90 年代中后期开始，依赖互联网传播的邮件病毒和宏病毒等大量涌现。
2. 病毒传播快，隐蔽性强，破坏性大。

<!-- .element style="font-size:70%;"-->

--

### 攻击病毒

攻击组织化、规模化，不再是单打独斗，而是有明确的政治、经济目标：

1. 典型代表是 2003 年的冲击波病毒和 2004 年的震荡波病毒。
2. 这些病毒利用操作系统的漏洞进行进攻性的扩散，不需要任何的媒介和操作，危害性更大。

<!-- .element style="font-size:70%;"-->

--

### 高级持续性威胁（APT）

现代黑客团体的“杰作”：

1. 不是一种病毒。
2. 是一种攻击手段。
3. Advanced / Persistent / Threat
4. 2010 年 Google 极光攻击，持续数月
5. 2011 年 夜龙攻击被 McAfee 曝光，始于 2007 年
6. 2010 年 伊朗核电站遭到 Stuxnet 蠕虫（震网）攻击
7. 2011 年 震网二代 Duqu 肆虐欧洲

<!-- .element style="font-size:70%;"-->

--

### 小结

可以看出恶意代码的发展趋势为：

- 网络化
- 专业化
- 多样化
- 自动化

<!-- .element style="font-size:70%;"-->

---

## 恶意代码分类

--

### 动机分类

按照恶意代码的动机分类：

![分类](/courses-wiki/img/malicious-code.png)<!-- .element: style="width:70%;" -->

<!-- .element style="text-align:center"-->

--

### 植入方式分类

按照恶意代码进入目标的方式，即植入方式分类：

- 源码型（恶意代码插入到源程序中，编译成为合法程序的一部分）
- 嵌入型（将自身嵌入到现有程序中，使恶意代码与目标程序代码成为一体，清除会破坏合法程序）
- 外壳型（一般链接到宿主程序的首尾，宿主程序执行首先激活恶意代码）
- 操作系统型（加入或者取代部分操作系统进行工作，寄生在计算机磁盘的操作系统区）

<!-- .element style="font-size:70%;"-->

--

### 寄生方式分类

按照恶意代码进入目标后的驻留方式，即寄生方式分类：

- 引导型（恶意代码程序取代正常的引导记录，占据了引导区的物理位置即可获得控制权）
- 文件型（通过操作系统的文件系统实施感染，以感染可执行文件为主）
- 混合型（综合了引导型恶意代码和文件型恶意代码的特点同时感染文件和引导扇区，同时使用加密和变形算法）

<!-- .element style="font-size:70%;"-->

---

## 常见类型

--

### 宏病毒（Macro Virus）

利用办公套件中的宏实施恶意行为。

- 宏是微软为 Office 软件设计的功能，提供任务的自动化。如果宏中包含了有破坏能力的命令和自我复制的功能，这个宏就成了宏病毒。
- 宏病毒常见的是针对 Word / Excel / Powerpoint 等 Office 软件，通过宏录制器和 Visual Basic 编辑器来创建宏。
- 宏被存储在通用模板中，一执行程序，受感染的模板就会传播到所编辑的文档中去，并以此方式不断地感染。

<!-- .element style="font-size:70%;"-->

--

### 恶意脚本

以解释型语言为主体，实施恶意行为。

- 网页恶意脚本，比如：XSS、CSRF。
- 操作系统恶意脚本，比如：JS、bat、cmd 脚本。

<!-- .element style="font-size:70%;"-->

--

### 蠕虫病毒（Worm）

行为上更倾向于尽可能通过网络复制自身。

- 蠕虫强调自身副本的完整性和独立性，主要通过计算机漏洞来进行传染。
- 蠕虫主要利用系统和程序的漏洞主动攻击，传播方式多样，影响范围大，感染主机数量多。

<!-- .element style="font-size:70%;"-->

--

### 木马（Trojan Horse）

窃取信息或者控制目标以便进一步攻击。

- 木马一般有客户端和服务器端两个程序，植入的木马会发送系统信息给服务器端。
- 木马的基本特征是隐蔽性、自动运行、控制力强（远程控制，键盘记录等）。

<!-- .element style="font-size:70%;"-->

--

### 命名规则

![命名](/courses-wiki/img/malwarenaming.png)

- <span style="font-size:0.7em">Type: 恶意代码类型/分类</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:0.7em">Platform：感染/运行平台环境</span>
- <span style="font-size:0.7em">Family: 恶意代码家族名</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:0.7em">Variant: 变种名</span>
- <span style="font-size:0.7em">Information：扩展说明</span>

<p style="text-align:left;font-size:0.5em">注：https://docs.microsoft.com/zh-cn/windows/security/threat-protection/intelligence/malware-naming</p>

---

## 恶意代码原理

--

## 主要功能

恶意代码主要功能以及运行方式：

- 引导模块，使恶意代码获得执行并使后面的两个模块处于激活状态。
- 传染模块，传染条件满足时把恶意代码传染到被攻击的对象上。
- 破坏模块，在恶意代码破坏，发作条件满足时，实施对系统的干扰和破坏活动。
- 寄生对象包括：磁盘引导扇区、特定可执行文件、系统文件、PDF、Word 类文档等。
- 驻留内存方式：占据磁盘引导区中系统引导程序的位置，系统启动时自动装入内存获得控制权；修改原文件使对该文件的操作转入病毒的引导模块，窃取系统控制权然后恢复系统功能。

<!-- .element style="font-size:70%;"-->

--

### 传染机制

现代恶意代码往往尝试多种途径实现传播：

- 传染是恶意代码由一个载体传播到另一个载体，由一个系统进入另一个系统。
- 被动传染是基于系统的复制和系统 I/O 传输工作进行的，比如网络传输或者 U 盘等外部存储设备。
- 主动传染时系统常驻内存并监视系统运行，伺机采取手段传染。

<!-- .element style="font-size:70%;"-->

--

## 触发规则

常见的恶意代码触发条件包括：

- 日期触发
- 键盘触发
- 启动触发
- 邮件触发
- 漏洞触发
- 磁盘访问触发

<!-- .element style="font-size:70%;"-->

---

## 关键技术

--

### 概览

恶意代码往往采用一些共性的技术。

![关键技术](/courses-wiki/img/malwaretech.png)<!-- .element: style="width:70%;" -->

<!-- .element style="text-align:center"-->

--

### 自我复制

恶意代码可以利用代码实现自我复制，也可能利用社会工程学手段。

![社会工程学](/courses-wiki/img/social-engineering.png)<!-- .element: style="width:60%;" -->

<!-- .element style="text-align:center"-->

--

### 隐藏

恶意代码为了避免被目标发现，采取多种隐藏手段。

- 变形，混淆，加密等手段来躲避杀毒软件。
- Rootkit 技术，比如文件隐藏、注册表隐藏、网络连接隐藏、进程隐藏来防止被用户发现。
- 不驻留文件系统、注册表，比如驻留 BIOS，MBR，内存。
- 还可以动态加载寄生于其他正常进程。

<!-- .element style="font-size:70%;"-->

--

### 传播

恶意代码在传播过程中也会根据目标选择不同手段。

- 社会工程学手段，比如电子邮件，即时通信，网站，SNS等。
- 基于漏洞的传播，比如漏洞利用代码中包含恶意代码。
- 最常见的是文件捆绑，在下载的破解软件中捆绑恶意代码、手机第三方定制 ROM 中预置恶意代码、电子邮件附件等。

<!-- .element style="font-size:70%;"-->

--

### 控制

以木马为代表的恶意代码会通过多种手段对目标进行控制：

- 主动监听，等待连接
- 反向连接，绕过防火墙
- 主动接受指令
- 远程控制(网页，邮件，DNS 解析，IRC)
- 屏幕监控
- 键盘记录

<!-- .element style="font-size:70%;"-->

---

## 恶意代码分析与检测

--

## 恶意代码分析方法

恶意代码的分析典型分为静态分析和动态分析。

- 静态分析是指利用反汇编工具将恶意代码转换为源代码或汇编代码进行分析，发现恶意代码的模块组成，编程技巧，感染方法，标示特征代码。
- 动态分析是指在恶意代码执行的情况下，利用程序调试工具进行跟踪和观察，确定工作过程。

<!-- .element style="font-size:70%;"-->

--

### 特征代码检测法

计算机病毒中一般都带有明显的特征代码，该方法是最为普遍的病毒检测方法。

- 优点：检测准确快速，误报率低。
- 缺点：从未见过的病毒无法检测、必须不断更新病毒库，随着病毒种类的增加、检索时间变长，不能检测多态和隐蔽性病毒。

<!-- .element style="font-size:70%;"-->

--

### 校验和检测法

根据正常文件的信息（名称，大小，内容），计算其校验和，通过检查校验和来判断是否发现病毒。

- 优点：方法简单，可以发现已知和未知的病毒。
- 缺点：对文件内容的变化过于敏感、误报率高，影响文件运行速度、不能对付隐蔽性病毒。

<!-- .element style="font-size:70%;"-->

--

### 行为监测法

利用病毒的特有行为特征来监测病毒的方法称为行为监测法。

- 优点：可发现未知病毒，准确的预报未知的多种病毒。
- 缺点：可能误报警，不能识别病毒名称，实现有一定的难度。

<!-- .element style="font-size:70%;"-->

---

## Q & A
